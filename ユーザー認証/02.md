# ユーザ認証を作成する 02 (VaadinWebSecurity)

## 認証済でなければ利用できないページを用意

### パッケージの追加

`com.example.vsbp.page` パッケージの中に、新たに `signed` パッケージを作成する。

`com.example.vsbp.page.signed` パッケージの中のページは、全てユーザー認証済みでなければ利用できないという分け方にする。

### SignedPage の作成

`com.example.vsbp.page.signed` パッケージの中に、ユーザー認証後に表示される SignedPage を作成する。

#### SignedPage.java

```java
import com.example.vsbp.service.IUserService;
import com.vaadin.flow.component.html.H1;
import com.vaadin.flow.component.html.Paragraph;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import org.springframework.beans.factory.annotation.Autowired;

@PageTitle("SignedPage")
@Route("Signed")
public class SignedPage extends VerticalLayout {

    private final IUserService userService;

    @Autowired
    public SignedPage(IUserService userService) {
        this.userService = userService;

        var headLine = new H1("認証後");
        String userName = "test";

        var nameText = new Paragraph("あなたは" + userName + "さんです");
        add(headLine, nameText);
    }
}
```

### ここまでの動作確認

vsbpApplciation を再起動し、 `http://localhost:8080/Signed` を表示し、プログラムの通り動作していることを確認する。

本来このページはユーザ認証後にのみ使えるはずであるが、今はまだその仕組みをいれていないので、ユーザ認証の有無にかかわらず、ページの内容が表示されてしまう状況である。

## ユーザ認証の仕組みを導入

Vaadin＋Spring Bootの環境でユーザ認証の仕組みを導入するのには様々な方法がある。今回はそのうち、Vaadinで用意されている、Spring-Securityの拡張であるVaadinWebSecurityを使用した認証を実装する。

↓ MySessionいる？
<!-- ### 認証結果を一次記憶しておくクラスの作成

基本的なユーザ認証では、利用者のブラウザの認証・認証済みを一時的に記憶しておく HTTPセッション という領域を用いる。この Session 用のクラスを作成する。

`com.example.vsbp` パッケージに、MySessionクラスを作成する。

```java
package com.example.vsbp;

import org.apache.wicket.Session;
import org.apache.wicket.authroles.authentication.AbstractAuthenticatedWebSession;
import org.apache.wicket.authroles.authorization.strategies.role.Roles;
import org.apache.wicket.request.Request;

import java.util.Objects;

// ブラウザ事に異なる情報を一時保存できるセッション
public class MySession extends AbstractAuthenticatedWebSession {

  // 認証の際に照合したユーザー名
  private String userName;

  public MySession(Request request) {
    // コンストラクタ。初期状態は認証NG（userName = null）
    super(request);
    this.userName = null;
  }

  public void sign(String userName) {
    // 認証したユーザを変更する。
    // セキュリティ上の配慮から、セッションを切り替える（古いセッションを使い回さない）
    replaceSession();
    this.userName = userName;
  }

  @Override
  public Roles getRoles() {
    // 認証結果OK(userName = ユーザー名)だった場合は、誰もが "USER" 権限を持っているとして返す
    // 認証結果NG(userName = null）だった場合は、権限なしとして返す
    // wicket-auth-roles　では、この権限の有無と種類でページを表示してよいか判断してくれる
    if (isSignedIn()) {
      return new Roles(Roles.USER);
    }
    return new Roles();
  }

  @Override
  public boolean isSignedIn() {
    // 認証結果OK(userName = ユーザー名)だった場合は、trueを返す
    // 認証結果NG(userName = null）だった場合は、falseを返す
    return Objects.nonNull(this.userName);
  }

  public String getUserName() {
    // ユーザー名 を返す
    return this.userName;
  }

  public static MySession get() {
    // サーバーの中から Session を取り出す
    return (MySession) Session.get();
  }

}
```

userName にユーザー名が入力されていば認証OK（認証済み）、userName が `null` であれば認証NG（未認証）と判断できるようにしている。

色々なメソッドを作成しているが、特に重要なのは以下のメソッドである。

- **sign メソッド**<br>別の場所で行われた認証（照合）が成功したら、照合できたユーザ名を一時記録する。セッションはブラウザごとに用意されるので、ブラウザごとの利用者のユーザ名となる。
- **getRoles メソッド**<br>認証したユーザの役割を返り値にする。<strong>Wicketはこの値を使って、ページを表示してよいかダメかを判定する</strong>。この例では全員が `USER`（一般ユーザ） という役割になると一律で設定しているが、ユーザごとに管理者や他の役割（学生、教育、ゲスト...）を区別するようにもできる。
- **get メソッド**<br>クラスメソッド（staticなメソッド）なので、インスタンス化（new）せずに利用できる。Wicketでセッション情報を変更したり取り出したりするときは、必ずこのメソッド経由で行う（後述）。 -->

### ユーザ認証をONにする

SignedPageは現状では認証なしでも閲覧できるようになっている。
 **Vaadin(Spring-Security)の認証機能を利用するように変更**する。

#### pom.xml を変更

最初のほうで `Spring-Security` を一時的にオフにするために、`pom.xml` の内容の一部をコメントアウトしたのを覚えているだろうか。ユーザ認証をオンにするために、コメントアウトを解除しよう。
### `<dependency> </dependency>`の一部のコメントアウトを解除する

変更前
```xml
<dependencies>
  <!-- 中略 -->

  <!--<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
  </dependency>-->

  <!-- 中略 -->

  <!--<dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-test</artifactId>
      <scope>test</scope>
  </dependency>-->

  <!-- 中略 -->
```

変更後
```xml
<dependencies>
  <!-- 中略 -->

  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
  </dependency>

  <!-- 中略 -->

  <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-test</artifactId>
      <scope>test</scope>
  </dependency>

  <!-- 中略 -->
```



- 該当箇所を選択し、ctrl + / を押すとコメントアウト解除できる。

この変更により、Vaadin(Spring)の認証機能が使えるようになる。<br>
**※pomの再ロード(最新版IntelliJ IDEAではプロジェクトの同期)を忘れずに！！**

#### SignedPage を変更

**SignedPage を認証済みの時のみ利用できるように変更** する。

具体的には、認証済みであれば表示できるようにするページに、`@ PermitAll` アノテーションを設定する。

```java
import jakarta.annotation.security.PermitAll; // import文の追加

// ↓ どの役割のユーザであれば表示してよいか。
// 認証済みユーザであれば例外なくアクセスできる@PermitAll
@PageTitle("SignedPage")
@Route("Signed")
@PermitAll
public class SignedPage extends VerticalLayout {

          // 中略

}
```

しかし、Spring-Security のデフォルトの設定ではアプリケーション実行時にあらかじめ用意されたログイン用ページが表示され、何も設定しないままだと何を入力してもログインページにリダイレクトされてしまう。これを確認しよう。

### ここまでの動作確認

vsbpApplciation を再起動し、今まで作成してきたページを表示する。

このままではユーザー認証の設定が終わっていないので、上述したようにデフォルトのログインページにリダイレクトされる。

次はこの問題を解消するために、セキュリティ用コンフィグやログイン(サインイン)用のページを作成していく。

[目次へ戻る](../README.md)  &emsp;&emsp;[前の項目へ](./01.md) &emsp;&emsp;[次の項目へ](./03.md)